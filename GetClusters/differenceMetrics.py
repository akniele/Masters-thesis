import numpy as np
from scipy.stats import entropy  # kl-divergence/relative entropy if optional parameter qk is given,
# else calculate Shannon entropy


def sort_probs(big_probs, small_probs=None):
    #big_probs = big_probs.numpy()
    indices = np.argsort(big_probs, axis=-1, kind='stable')  # get indices to sort by
    indices_reverse = indices[:, :, ::-1]
    big_probs_sorted = np.take_along_axis(big_probs, indices_reverse, axis=-1)
    if small_probs is not None:
        #small_probs = small_probs.numpy()
        small_probs_sorted = np.take_along_axis(small_probs, indices_reverse, axis=-1)
        return big_probs_sorted, small_probs_sorted, indices

    return big_probs_sorted


def get_entropy_feature(probs0, probs1, indices=None, top_p=None):  # indices and top_p are dummy parameters, not used
    small_entropies = entropy(probs0, axis=-1)
    big_entropies = entropy(probs1, axis=-1)
    entropy_diff = big_entropies - small_entropies
    entropy_diff = np.expand_dims(entropy_diff, -1)
    return entropy_diff


def bucket_diff_top_k(probs0, probs1, indices=None, top_p=None):  # top_p is dummy parameter, not used
    """
    calculates the difference in the summed probability between distribution pairs, bucket-wise
    :param probs0: 3-dim numpy array, distributions generated by the smaller model
    :param probs1: 3-dim numpy array, distributions generated by the bigger model
    :param indices: a list of indices at which to split prob0 and prob1
    :return: 3-dim numpy array, differences between summed probability per distribution pair per bucket
    """
    if indices is None:
        indices = [10, 35]

    big_sample_sorted, small_sample_sorted, _ = sort_probs(probs1, probs0)
    split_probs_big = np.split(big_sample_sorted, indices, axis=-1)
    split_probs_small = np.split(small_sample_sorted, indices, axis=-1)

    def calculate_bucket_diff(distr1, distr0):
        """
        calculates difference in summed probability per subarray
        :param distr1: subarray of distributions generated by bigger model
        :param distr0: subarray of distributions generated by smaller model
        :return: array of differences, last dimension has same length as num buckets
        """
        return np.sum(distr1, axis=-1) - np.sum(distr0, axis=-1)

    bucket_diffs = np.array(list(map(calculate_bucket_diff, split_probs_big, split_probs_small)))
    print(f"bucket diffs from function: {bucket_diffs}")
    bucket_diffs = np.moveaxis(bucket_diffs, 0, -1)

    return bucket_diffs


def get_top_p_difference(probs0, probs1, indices=None, top_p=0.9):  # indices is dummy parameter, not used
    sorted_probs0 = np.sort(probs0, axis=-1, kind='stable')
    sorted_probs1 = np.sort(probs1, axis=-1, kind='stable')
    cumsum0 = np.cumsum(sorted_probs0, axis=-1)
    cumsum1 = np.cumsum(sorted_probs1, axis=-1)
    mask0 = cumsum0 >= top_p
    mask1 = cumsum1 >= top_p

    current_k0 = np.argmax(mask0, axis=-1)
    current_k1 = np.argmax(mask1, axis=-1)
    diff = current_k1 - current_k0
    diff = np.expand_dims(diff, axis=-1)
    return diff
